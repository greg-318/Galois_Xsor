# Составной генератор псевдослучайных двоичных последовательностей
# Окончательная версия
# Конфигурация Галуа (5 xor 4 xor 3)
# Нелинейный выход
# Динамический выбор схемы обратных связей (отводов)
# Рисунок (последний)

# Секретный ключ (один из 24!), определяет порядок смены отводов
secret_key=[
            [0,0,0],
            [0,0,1],
            [0,1,0],
            [0,1,1],
            [1,0,0],
            [1,0,1],
            [1,1,0],
            [1,1,1],
            [2,0,0],
            [2,0,1],
            [2,1,0],
            [2,1,1],
            [3,0,0],
            [3,0,1],
            [3,1,0],
            [3,1,1],
            [4,0,0],
            [4,0,1],
            [4,1,0],
            [4,1,1],
            [5,0,0],
            [5,0,1],
            [5,1,0],
            [5,1,1],
]

# Таблицы конечных ключей (полиномов), определяющих схемы отводов - 24 варианта
sh1=[[1,0,0,1,0],[1,0,1,0,0],[1,0,1,1,1],[1,1,0,1,1],[1,1,1,0,1],[1,1,1,1,0]]
sh2=[[1,0,0,1],[1,1,0,0]]
sh3=[[1,0,1],[1,1,0]]

# В программе используются фиксированные начальные установки регистров (IV)
# Всего же количество вариантов = (5+4+3) в степени 2
# reg = []

reg1=[1,0,1,0,1]
reg2=[1,0,1,1]
reg3=[0,1,1]

# Гаммы (начальная установка - пусто)
gamma1=[]
gamma2=[]
gamma3=[]
gamma=[]

# Большой цикл с динамическим переключением схемы отводов
for k in range(0,24):

    # Работа генератора (3255 циклов)
    for i in range (0,3255):

        gamma.append((reg1[0]^reg1[4]^(reg1[2]&reg1[3]))^(reg2[0]^reg2[3]^(reg2[1]&reg2[2]))^(reg3[0]^reg3[2]^(reg3[0]&reg3[1])))

        # Регистр 1 (5 bit)
        scheme1=sh1[secret_key[k][0]]
        gamma1.append(reg1[0]^reg1[4]^(reg1[2]&reg1[3]))
        s1=reg1[4]
        for j in range (4,0,-1):
            reg1[j]=(s1*scheme1[j])^reg1[j-1]
        reg1[0]=s1*scheme1[0]

        # Регистр 2 (4 bit)
        scheme2=sh2[secret_key[k][1]]
        gamma2.append(reg2[0]^reg2[3]^(reg2[1]&reg2[2]))
        s2=reg2[3]
        for j in range (3,0,-1):
            reg2[j]=(s2*scheme2[j])^reg2[j-1]
        reg2[0]=s2*scheme2[0]

        # Регистр 3 (3 bit)
        scheme3=sh3[secret_key[k][2]]
        gamma3.append(reg3[0]^reg3[2]^(reg3[0]&reg3[1]))
        s3=reg3[2]
        for j in range (2,0,-1):
            reg3[j]=(s3*scheme3[j])^reg3[j-1]
        reg3[0]=s3*scheme3[0]

# Выходные гаммы
print(gamma1)
print(gamma2)
print(gamma3)
print(gamma)

# Вывод гаммы в файл
import pickle
f=open(r'GammaFile.txt','wb')
pickle.dump(gamma,f)
f.close()

